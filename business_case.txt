Task 1: Create a business case for your Python application 

 

Create and document a high-level design for the application that incorporates:  

 

An overview of what the application does and why 

An instruction on how to run the app 

A Use Case UML Diagram describing the actors and basic functionality of the application. 

Activity, State Machine & basic Class UML diagrams, as needed. 

A specification containing data types and validation rules. 

The application/program structure showing the navigation, simple text-based screen layouts and a brief description of the functionality of each element. 

Clarify the local storage of data. 

 

 

Note: It is recommended you create diagrams using a drawing package such as draw.io. The package provides all the standard UML templates and is easy to use. Export your finished diagram and insert it as an image. Please ensure the diagram and any included text is readable. 

 

This organization is a consultancy called PA Consulting that deals with the monitoring and digital resilience of software for one of its clients. This is done by making maturity assessments of the applications used; auditing the effectiveness and capability of the cybersecurity practices. Once this is done, policies will be procured aligned with the Government standard. Procedures for each application would be created to allow for an effective response. Making sure that each procedure aligned with each policy. These policies and maturity assessments are documented in Microsoft Word or Excel. These documents are normally stored in teams and do not have a bespoke place where they can be stored, fetched, and edited.  

The running requirements is: 

Docker 

Python 

To run this correctly run these commands: 

$ bash build_app.sh - this runs the API. 

$ bash run_app.sh (in a separate terminal) - this runs the terminal app. 

  

To unit test: 

$ bash build_app.sh 

$ bash run_unit.sh (in a separate terminal) 

The application navigates using a integer to show which action will be taken, then the corresponding data will be inputted. 

 

Each maturity assessment has a recursive set of categories, subcategories, ratings with each rating having a corresponding question, grade and set of evidence. Teams is used to manage the files. My application creates an interface that allows communication with data. Allowing for each category to be fetched and filtered individually avoiding the need to fetch an entire maturity assessment. If data on question ratings alone among other maturity assessments is required. It can be queried. 

 

To allow connected querying, the python API (FastAPI) will communicate to a normalized SQL database to map their datatypes and data lengths rigidly, each being referenced to a foreign key. SQL was used to avoid the possible errors that would come from locally reading and writing to separate JSON files and allow separate querying. Whilst also Circumventing, redundancy and allowing specific sub fields like subcategories or functions to be included in the query to provide all questions corresponding to those filtering statements. Committing the following POST, GET, UPDATE and DELETE method operations to enact actions. 

 

This figure shows the data types, lengths of each value, and relationships. This could have been displayed in a pythonic way, but it made more sense to do it in SQL seeing that it is translatable.  

The function, category and subcategory were set as CHAR(length) datatypes which is a string that specifies and only allows a string with that length.  

The question rating and email were VARCHARs() to allow variable strings. The password, evidence and question were TEXT datatypes to allow for longer strings. 

From Maturity Assessment to Questions each entity has a one-to-many relationship meaning that each record would be connected to several further subfields. 

Grades are a separate INT field to grade the subcategory. 

Authentication using JWT tokens will be used to ensure unauthorized users cannot access the document. Once a maturity assessment is created the author can provide access to the maturity assessment or revoke it. All to ensure a cybersecurity aspect to the application. 

 

The application uses object-oriented programming to categorize the specific operations. Using aggregation and association practices to achieve their functions. 

 

MaturitySQL is the class that handles the SQL connection to the database and executes the SQL commands at a functional low level using Python. The type of commands isnâ€™t considered in this class. The sole goal is to create a connection, execute the command then return the result. MaturityCRUD breaks these SQL commands into the respective Create Retrieve Update Delete framework. Rather than having to write an SQL command each time the function can just be called. MaturityCRUD has a composition relationship with MaturitySQL; seeing that a database connection is required to execute the commands.  

Maturity_Create_Tables sets up the field schema and schema types, finally creating the tables if they do not exist. Using MaturityCrud as a parameter, producing another composition relationship. 

SQL Ops deals with the more complex problem specific formulations. In this case checking if a maturity assessment question exists or to check if a user has access. This requires bothe MaturityCRUD and Maturity_Create_Tables to function. 

MaturityJWT is a class that handles JWT authentication and has an aggregation relationship with MaturityCRUD. MaturityCRUD is used in the class, but it is not required for the class to function. 

MaturityHash deals with the hashing and authorization for passwords when the passwords are stored in the database. According to the GDPR (General Data Protection Regulation) policies a password must be stored in a database as a hash for security. Salt is added to the hash to improve the cracking difficulty. 

These classes all compose to produce the CRUD operations on the maturity assessments and on their respective Api routes. Allowing for maturity assessments to be created updated, fetched, and deleted in a secure way. 